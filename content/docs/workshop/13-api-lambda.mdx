---
title: "API Lambda (Persons + Photos)"
description: "Create a small HTTP Lambda that returns People grid + Person detail data for the beetroot React app."
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tabs, Tab } from "fumadocs-ui/components/tabs";
import { Steps, Step } from "fumadocs-ui/components/steps";

## Goal

By the end of this phase, you'll have a **backend API Lambda** that can power two React screens:

1. **People grid**

```txt
GET /persons → returns { personId, photoCount, repThumbKey }
```

2. **Person detail**

```txt
GET /persons/{personId}/photos → returns { photoId, photoBucket, photoKey, thumbKey }
```

<Callout type="info" title="Why do we need an API at all?">
  Your React app should not query DynamoDB directly. A small API Lambda acts
  like a safe “middle layer” that reads DynamoDB and returns only what the UI
  needs.
</Callout>

## What we already have

From earlier phases, your DynamoDB data is now ready:

- **Persons**: `personId`, `photoCount`, `repThumbKey`
- **Occurrences**: for a `personId`, gives `photoId` + `thumbKey`
- **Photos**: for a `photoId`, gives original `s3Bucket` + `s3Key`

## Create API Lambda

<Steps>
  <Step>
    ### Create function

    AWS Console → **Lambda → Create function**

    - **Name:** <code>beetroot-api</code>
    - **Runtime:** Python 3.12
    - **Permissions:** Create a new role (or reuse temporarily)

    <Callout type="tip" title="About the role">
      It's okay to reuse a role temporarily while learning. We'll tighten permissions later once everything is working.
    </Callout>

  </Step>

  <Step>
    ### Add environment variables

    Lambda → **Configuration → Environment variables** → Add:

    - <code>PERSONS_TABLE</code> = <code>Persons</code>
    - <code>OCCURRENCES_TABLE</code> = <code>Occurrences</code>
    - <code>PHOTOS_TABLE</code> = <code>Photos</code>

    <Callout type="info" title="Why env vars?">
      Table names change from project to project. Environment variables keep your code reusable and clean.
    </Callout>

  </Step>
</Steps>

## API Lambda Code

### What this code does

This Lambda behaves like a tiny HTTP router:

- reads <code>method</code> + <code>path</code> from the incoming request
- returns JSON + CORS headers
- supports 2 routes:

```
GET /persons
GET /persons/{personId}/photos
```

## Part 1: Imports + DynamoDB table handles

This section connects to DynamoDB and prepares table objects.

```python
import json
import os
from decimal import Decimal

import boto3
from boto3.dynamodb.conditions import Key

ddb = boto3.resource("dynamodb")

PERSONS_TABLE = ddb.Table(os.environ.get("PERSONS_TABLE", "Persons"))
OCC_TABLE = ddb.Table(os.environ.get("OCCURRENCES_TABLE", "Occurrences"))
PHOTOS_TABLE = ddb.Table(os.environ.get("PHOTOS_TABLE", "Photos"))
```

<Callout type="tip" title="Why Key from boto3.dynamodb.conditions?">
  We use <code>Key("personId").eq(person_id)</code> to query the{" "}
  <code>Occurrences</code> table efficiently by partition key.
</Callout>

## Part 2: Make JSON safe for DynamoDB numbers (Decimal)

DynamoDB numbers come back from boto3 as <code>Decimal</code>.
Python's <code>json.dumps()</code> cannot serialize <code>Decimal</code> unless we convert it.

Add this helper once, and reuse it everywhere.

```python
def _json_default(o):
    if isinstance(o, Decimal):
        # Whole numbers (like photoCount=2) should stay integers
        if o % 1 == 0:
            return int(o)
        return float(o)
    raise TypeError(f"Object of type {o.__class__.__name__} is not JSON serializable")
```

<Callout type="info" title="Why do we need this?">
  Without this, you may see:{" "}
  <code>TypeError: Object of type Decimal is not JSON serializable</code>. This
  keeps your API responses valid JSON for React.
</Callout>

## Part 3: A helper to return JSON (with CORS)

Instead of repeating response formatting in every route, we create one helper:

```python
def _resp(status: int, body: dict):
    return {
        "statusCode": status,
        "headers": {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET,OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type",
        },
        "body": json.dumps(body),
    }
```

<Callout type="warning" title="About CORS = *">
  This is convenient for development. Later, you should restrict this to your
  real frontend domain.
</Callout>

## Part 4: Read method + path and handle OPTIONS

API calls always include a method and path.

Browsers may send an <code>OPTIONS</code> request (CORS preflight) before the real <code>GET</code>.

```python
def lambda_handler(event, context):
    method = event.get("requestContext", {}).get("http", {}).get("method") or event.get("httpMethod")
    path = event.get("rawPath") or event.get("path") or ""

    if method == "OPTIONS":
        return _resp(200, {"ok": True})
```

<Tabs items={["Input", "Output"]} groupId="phase13-options" persist> <Tab value="Input">
Browser sends a preflight:

<code>method = OPTIONS</code>
<br />
<code>path = /persons</code>

  </Tab>

  <Tab value="Output">
    Lambda returns <code>200</code> so the browser allows the real GET request.
  </Tab>
</Tabs>

## Part 5: Route 1 — `GET /persons`

This route returns the list of persons for your People grid.

In this workshop version, we do:

- <code>scan()</code> the table
- sort results by <code>photoCount</code> in Python

```python
if method == "GET" and path == "/persons":
    items = []
    resp = PERSONS_TABLE.scan(Limit=200)
    items.extend(resp.get("Items", []))
    while "LastEvaluatedKey" in resp and len(items) < 200:
        resp = PERSONS_TABLE.scan(ExclusiveStartKey=resp["LastEvaluatedKey"], Limit=200)
        items.extend(resp.get("Items", []))

    items.sort(key=lambda x: int(x.get("photoCount", 0)), reverse=True)

    return _resp(200, {"persons": items[:100]})
```

<Callout type="info" title="Why scan here?">
  Scan is not ideal for huge tables, but it's the simplest way to get started.
  Once you understand the flow, we can add a GSI for efficient sorting later.
</Callout>

## Part 6: Route 2 — `GET /persons/{personId}/photos`

### What this route does

When the UI opens a person's page, it needs:

- **which photos** this person appears in
- the **thumbnail** for each appearance
- the **original photo location** (bucket + key) so the UI can load it later

We build that response by combining data from **two tables**:

1. **Occurrences** (fast query by `personId`)
2. **Photos** (lookup by `photoId`)

### 6.1: Validate the path and extract `personId`

We only accept paths like:

- `/persons/<personId>/photos`

<Tabs items={["Code", "Input", "Output"]} groupId="phase13-parse-personid" persist>
 <Tab value="Code">
```python
parts = path.strip("/").split("/")
if len(parts) != 3:
    return _resp(400, {"error": "bad path"})
person_id = parts[1]
 ```
</Tab>

  <Tab value="Input">
    Example path:

```
/persons/0c7d4865.../photos
```

  </Tab>

  <Tab value="Output">
    Extracted value:

```
person_id = "0c7d4865..."
```

  </Tab>
</Tabs>

<Callout type="tip" title="Why do we parse the path manually?">
  Right now, we don't have API Gateway routing yet. We're keeping the Lambda
  logic simple and readable. Later, the HTTP layer can map this route
  automatically.
</Callout>

### 6.2: Query `Occurrences` by `personId`

The **Occurrences table** is designed exactly for this query:

- Partition key: `personId`
- Sort key: `photoId`

So we can fetch all photos for a person using a single query.

<Tabs items={["Code", "Input", "Output"]} groupId="phase13-occ-query" persist>
<Tab value="Code">
```python
occ = OCC_TABLE.query(
    KeyConditionExpression=Key("personId").eq(person_id),
    Limit=200
).get("Items", [])
```
</Tab>

<Tab value="Input">
  <code>person_id = "0c7d4865..."</code>
</Tab>

  <Tab value="Output">
```json
occ = [
  {"photoId": "fe40...", "thumbKey": "faces-thumbs/0c7d.../fe40_face_1.jpg", ...},
  ...
]
```
  </Tab>
</Tabs>

<Callout type="info" title="Why not scan Occurrences?">
  A scan reads the full table. A query reads only the partition you want. That's
  why we designed Occurrences with PK = personId.
</Callout>

### 6.3: Fetch the original photo info from `Photos`

Occurrences tells us **photoId**, but the UI also needs where the photo lives:

- `s3Bucket`
- `s3Key`

That info is stored in the **Photos table**, so we fetch it.

```python
photos = []

for o in occ:
    photo_id = o.get("photoId")
    if not photo_id:
        continue

    p = PHOTOS_TABLE.get_item(
        Key={"photoId": photo_id}
    ).get("Item")
    if not p:
        continue
```

<Tabs items={["Code", "Input", "Output"]} groupId="phase13-photos-getitem" persist> <Tab value="Code">
```python
p = PHOTOS_TABLE.get_item(
    Key={"photoId": photo_id}
).get("Item")
```
</Tab>

<Tab value="Input">
  <code>photo_id = "fe40..."</code>
</Tab>

  <Tab value="Output">
```json
p = {
  "photoId": "fe40...",
  "s3Bucket": "beetroot-raw",
  "s3Key": "photos-raw/st5.jpg",
  ...
}
```
  </Tab>
</Tabs>

<Callout type="tip" title="Why do we need Photos table here?">
  Occurrences is “person ↔ photo link”. Photos is the single source of truth for
  the original S3 path.
</Callout>

### 6.4: Build the response objects for the UI

Now we combine:

- `thumbKey` from **Occurrences**
- `s3Bucket` + `s3Key` from **Photos**
- and return a clean list React can use

<Tabs items={["Code", "Input", "Output"]} groupId="phase13-merge-output" persist>

<Tab value="Code">
```python
photos.append({
    "photoId": photo_id,
    "photoBucket": p.get("s3Bucket"),
    "photoKey": p.get("s3Key"),
    "thumbKey": o.get("thumbKey"),
})
```
</Tab>

  <Tab value="Input">
From `Occurrences`:

```
o.thumbKey = "faces-thumbs/0c7d.../fe40_face_1.jpg"
```

From `Photos`:

```
p.s3Bucket = "beetroot-raw"
p.s3Key = "photos-raw/st5.jpg"
```

  </Tab>

  <Tab value="Output">
    One UI-ready entry:

```json
{
  "photoId": "fe40...",
  "photoBucket": "beetroot-raw",
  "photoKey": "photos-raw/st5.jpg",
  "thumbKey": "faces-thumbs/0c7d.../fe40_face_1.jpg"
}
```

  </Tab>
</Tabs>

### 6.5: Return the final JSON response

```python
return _resp(200, {"personId": person_id, "photos": photos})
```

<Callout type="info" title="Student question: is this efficient?">
  This is “good enough” for learning, but doing many <code>get_item</code> calls
  is slower. Later, we can optimize this with <b>BatchGet</b> once the API works
  end-to-end.
</Callout>

## Part 7: Default route (404)

If the request doesn't match any of the two routes:

```python
return _resp(404, {"error": "not found", "path": path})
```

## Lambda Code

```python title="beetroot-api/lambda_function.py" lineNumbers
import json
import os
from decimal import Decimal

import boto3
from boto3.dynamodb.conditions import Key

ddb = boto3.resource("dynamodb")

PERSONS_TABLE = ddb.Table(os.environ.get("PERSONS_TABLE", "Persons"))
OCC_TABLE = ddb.Table(os.environ.get("OCCURRENCES_TABLE", "Occurrences"))
PHOTOS_TABLE = ddb.Table(os.environ.get("PHOTOS_TABLE", "Photos"))


def _json_default(o):
    if isinstance(o, Decimal):
        if o % 1 == 0:
            return int(o)
        return float(o)
    raise TypeError(f"Object of type {o.__class__.__name__} is not JSON serializable")


def _resp(status: int, body: dict):
    return {
        "statusCode": status,
        "headers": {
            "Content-Type": "application/json",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET,OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type",
        },
        "body": json.dumps(body, default=_json_default),
    }


def lambda_handler(event, context):
    method = event.get("requestContext", {}).get("http", {}).get("method") or event.get("httpMethod")
    path = event.get("rawPath") or event.get("path") or ""

    if method == "OPTIONS":
        return _resp(200, {"ok": True})

    if method == "GET" and path == "/persons":
        items = []
        resp = PERSONS_TABLE.scan(Limit=200)
        items.extend(resp.get("Items", []))
        while "LastEvaluatedKey" in resp and len(items) < 200:
            resp = PERSONS_TABLE.scan(ExclusiveStartKey=resp["LastEvaluatedKey"], Limit=200)
            items.extend(resp.get("Items", []))

        items.sort(key=lambda x: int(x.get("photoCount", 0)), reverse=True)
        return _resp(200, {"persons": items[:100]})

    if method == "GET" and path.startswith("/persons/") and path.endswith("/photos"):
        parts = path.strip("/").split("/")
        if len(parts) != 3:
            return _resp(400, {"error": "bad path"})
        person_id = parts[1]

        occ = OCC_TABLE.query(
            KeyConditionExpression=Key("personId").eq(person_id),
            Limit=200
        ).get("Items", [])

        photos = []
        for o in occ:
            photo_id = o.get("photoId")
            if not photo_id:
                continue
            p = PHOTOS_TABLE.get_item(Key={"photoId": photo_id}).get("Item")
            if not p:
                continue
            photos.append({
                "photoId": photo_id,
                "photoBucket": p.get("s3Bucket"),
                "photoKey": p.get("s3Key"),
                "thumbKey": o.get("thumbKey"),
            })

        return _resp(200, {"personId": person_id, "photos": photos})

    return _resp(404, {"error": "not found", "path": path})
```
